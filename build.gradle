import com.vanniktech.maven.publish.DeploymentValidation
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
	alias(libs.plugins.idea)
	alias(libs.plugins.jacoco)
	alias(libs.plugins.jacoco.report.aggregation)
	alias(libs.plugins.java)
	alias(libs.plugins.maven.publish)
	alias(libs.plugins.post.compile.weaving) apply false
	alias(libs.plugins.spotless)
}

dependencies {
	subprojects.forEach { sub ->
		jacocoAggregation sub
	}
}

reporting {
	reports.create('unitTestCodeCoverageReport', JacocoCoverageReport) {
		testSuiteName = 'test'
	}
}

spotless {
	java {
		target "**/src/**/*.java"
		googleJavaFormat(libs.versions.googleJavaFormat.get()).aosp().formatJavadoc(true)
		importOrder "", "javax", "java", "\\#"
		removeUnusedImports()
		forbidWildcardImports()
		formatAnnotations()
		endWithNewline()
	}

	groovyGradle {
		target '**/*.gradle'
		greclipse()
		trimTrailingWhitespace()
		endWithNewline()
	}
}

subprojects {
	apply plugin: 'jacoco'

	plugins.withId(libs.plugins.java.library.get().pluginId) {
		java {
			toolchain {
				languageVersion = JavaLanguageVersion.of(project.javaVersion.toInteger())
			}
		}

		configurations {
			mockitoAgent
		}

		configurations.configureEach {
			resolutionStrategy {
				force "org.aspectj:aspectjrt:${libs.versions.aspect.jrt.get()}"
				force "org.aspectj:aspectjtools:${libs.versions.aspect.jrt.get()}"
			}
		}

		dependencies {
			mockitoAgent platform(libs.mockito.bom)
			mockitoAgent(libs.mockito.core) {
				transitive = false
			}

			testImplementation platform(libs.junit.bom)
			testImplementation platform(libs.mockito.bom)
			testImplementation libs.bundles.junit
			testImplementation libs.bundles.mockito

			testRuntimeOnly "org.junit.platform:junit-platform-launcher"
		}

		test {
			useJUnitPlatform()
			jvmArgs("-javaagent:${configurations.mockitoAgent.asPath}", "-Xshare:off")
			finalizedBy jacocoTestReport, jacocoTestCoverageVerification
			testLogging {
				events = [
					TestLogEvent.PASSED,
					TestLogEvent.SKIPPED,
					TestLogEvent.FAILED
				]
				showStandardStreams = false
				showExceptions = true
				showCauses = true
				exceptionFormat = TestExceptionFormat.FULL
				displayGranularity = 2
			}
			afterSuite { suite, result ->
				if (!suite.parent) {
					def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
					def startItem = "|  ", endItem = "  |"
					def repeatLength = startItem.length() + output.length() + endItem.length()
					println("\n" + ("-" * repeatLength) + "\n" + startItem + output + endItem + "\n" + ("-" * repeatLength))
				}
			}
		}

		jacocoTestReport {
			reports {
				xml.required.set(true)
			}
		}

		jacocoTestCoverageVerification {
			violationRules {
				rule {
					limit {
						counter = 'LINE'
						minimum = 0.85
					}
					limit {
						counter = 'BRANCH'
						minimum = 0.85
					}
				}
			}
		}

		tasks.withType(JavaCompile).configureEach {
			options.encoding = 'UTF-8'
		}
	}

	plugins.withId(libs.plugins.maven.publish.get().pluginId) {
		def artifactId = project.findProperty('artifactId') ?: { throw new GradleException("artifactId must be set in gradle.properties") }()

		mavenPublishing {
			publishToMavenCentral(true, DeploymentValidation.NONE)
			signAllPublications()
			coordinates(project.group.toString(), artifactId as String, project.version.toString())

			pom {
				name = artifactId
				description = project.findProperty('description') ?: artifactId
				url = 'https://github.com/govuk-one-login/ipv-cri-lime-shared'

				licenses {
					license {
						name = 'MIT License'
						url = 'https://github.com/govuk-one-login/ipv-cri-lime-shared/blob/main/LICENSE'
						distribution = 'repo'
					}
				}

				developers {
					developer {
						id = 'ipv-cri-lime'
						name = 'Lime'
						organization = 'Government Digital Service'
						organizationUrl = 'https://www.gov.uk/government/organisations/government-digital-service'
					}
				}

				scm {
					connection = 'scm:git:git://github.com/govuk-one-login/ipv-cri-lime-shared.git'
					developerConnection = 'scm:git:ssh://github.com/govuk-one-login/ipv-cri-lime-shared.git'
					url = 'https://github.com/govuk-one-login/ipv-cri-lime-shared'
				}
			}
		}

		def publishGroupPath = project.group.toString().replace('.', '/')
		def publishCheckUrl = "https://repo1.maven.org/maven2/${publishGroupPath}/${artifactId}/${project.version}/${artifactId}-${project.version}.pom"
		def publishCoordinates = "${project.group}:${artifactId}:${project.version}"

		tasks.matching { it.name == 'publish' }.configureEach {
			onlyIf {
				def connection = URI.create(publishCheckUrl).toURL().openConnection() as HttpURLConnection
				connection.requestMethod = 'HEAD'
				connection.connectTimeout = 5000
				connection.readTimeout = 5000

				try {
					def exists = connection.responseCode == 200
					if (exists) {
						println "SKIPPED: ${publishCoordinates} already published at this version"
					} else {
						println "PUBLISHING: ${publishCoordinates}"
					}
					return !exists
				} finally {
					connection.disconnect()
				}
			}
		}
	}
}

tasks.register('publishAll') {
	group = 'publishing'
	description = 'publishes all lib-* subprojects to central (skips already published versions)'

	dependsOn subprojects.findAll { it.name.startsWith('lib-') }.collect { ":${it.name}:publish" }
}

tasks.register('publishAllToMavenLocal') {
	group = 'publishing'
	description = 'for install of libs to local m2 (useful for testing new changes in other projects before publishing)'

	dependsOn subprojects.findAll { it.name.startsWith('lib-') }.collect { ":${it.name}:publishToMavenLocal" }
}

gradle.taskGraph.whenReady { graph ->
	if (graph.hasTask(':publishAllToMavenLocal')) {
		subprojects.each { subproject ->
			// disable signing when publishing to local m2
			subproject.tasks.withType(Sign).configureEach {
				enabled = false
			}
		}
	}
}
